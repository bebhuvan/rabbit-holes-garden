---
import Layout from '../../layouts/Layout.astro';
import Header from '../../components/Header.astro';
import Footer from '../../components/Footer.astro';
import { getCollection, type CollectionEntry } from 'astro:content';

export async function getStaticPaths() {
  const posts = await getCollection('posts');
  return posts.map((post) => ({
    params: { slug: post.slug },
    props: { post },
  }));
}

interface Props {
  post: CollectionEntry<'posts'>;
}

const { post } = Astro.props;
const { Content } = await post.render();
const { title, date, tags, embeds } = post.data;

// Calculate reading time
const wordCount = post.body.split(/\s+/).length;
const readingTime = Math.ceil(wordCount / 200);

// Format date
const formattedDate = new Intl.DateTimeFormat('en-US', {
  day: 'numeric',
  month: 'long',
  year: 'numeric'
}).format(new Date(date));

// Get related posts based on shared tags
const allPosts = await getCollection('posts', ({ data }) => !data.draft);
const relatedPosts = allPosts
  .filter(p => p.slug !== post.slug) // Exclude current post
  .map(p => ({
    ...p,
    sharedTags: p.data.tags.filter(tag => tags.includes(tag)).length
  }))
  .filter(p => p.sharedTags > 0) // Only posts with shared tags
  .sort((a, b) => b.sharedTags - a.sharedTags) // Sort by most shared tags
  .slice(0, 3); // Limit to 3 related posts

// JSON-LD structured data for blog post
const siteUrl = Astro.site || 'http://localhost:4322';
const postUrl = `${siteUrl}/posts/${post.slug}`;
const jsonLd = {
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": title,
  "description": post.data.excerpt,
  "author": {
    "@type": "Person",
    "name": post.data.author || "Bhuvanesh"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Rabbit Holes",
    "url": siteUrl
  },
  "datePublished": date.toISOString(),
  "dateModified": date.toISOString(),
  "url": postUrl,
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": postUrl
  },
  "keywords": tags.join(", "),
  "wordCount": wordCount,
  "timeRequired": `PT${readingTime}M`,
  "isPartOf": {
    "@type": "Blog",
    "name": "Rabbit Holes",
    "@id": siteUrl
  }
};
---

<Layout title={`${title} | Rabbit Holes`} description={post.data.excerpt}>
  <!-- JSON-LD for Blog Post -->
  <script type="application/ld+json" set:html={JSON.stringify(jsonLd)}></script>
  
  <div class="container">
    <Header />
    
    <article class="single-post">
      <header class="post-header">
        <h1 class="post-title">
          {title}
        </h1>
        <div class="post-meta">
          {formattedDate} • {readingTime} min read
          {post.data.author && <span> • by {post.data.author}</span>}
        </div>
      </header>
      
      <div class="post-content">
        <Content />
      </div>
      
      <div class="post-tags">
        {tags.map((tag) => (
          <a 
            href={`/tags/${tag}`} 
            class="tag"
          >
            #{tag}
          </a>
        ))}
      </div>
      
      <div class="post-actions">
        <button 
          class="share-btn"
          onclick={`copyLink('${post.slug}')`}
        >
          Copy Link
        </button>
        <button 
          class="share-btn"
          onclick={`sharePost('${post.slug}')`}
        >
          Share
        </button>
        <a 
          href="/"
          class="share-btn"
        >
          ← Back
        </a>
        <span class="copy-success" id={`copy-success-${post.slug}`}>
          Copied!
        </span>
      </div>
      
      <!-- Related Posts -->
      {relatedPosts.length > 0 && (
        <section class="related-posts">
          <h3 class="section-title">Related Discoveries</h3>
          <div class="related-posts-grid">
            {relatedPosts.map((relatedPost) => (
              <article class="related-post">
                <h4 class="related-post-title">
                  <a href={`/posts/${relatedPost.slug}`}>
                    {relatedPost.data.title}
                  </a>
                </h4>
                <p class="related-post-excerpt">
                  {relatedPost.data.excerpt}
                </p>
                <div class="related-post-tags">
                  {relatedPost.data.tags
                    .filter(tag => tags.includes(tag))
                    .slice(0, 2)
                    .map(tag => (
                      <span class="related-tag">#{tag}</span>
                    ))
                  }
                </div>
              </article>
            ))}
          </div>
        </section>
      )}

      <!-- Waline Comments -->
      <div class="comments-section">
        <h3 class="comments-title">Comments</h3>
        <div id="waline-comments"></div>
      </div>
    </article>
    
    <Footer />
  </div>
</Layout>

<!-- Waline CSS -->
<link
  rel="stylesheet"
  href="https://unpkg.com/@waline/client@v3/dist/waline.css"
/>

<!-- Waline JavaScript -->
<script type="module">
  import { init } from 'https://unpkg.com/@waline/client@v3/dist/waline.js';

  init({
    el: '#waline-comments',
    serverURL: 'https://rabbit-holes-comments.vercel.app',
    path: window.location.pathname,
    meta: ['nick', 'mail', 'link'],
    requiredMeta: ['nick'],
    placeholder: 'Share your thoughts about this discovery...',
    avatar: 'retro',
    avatarCDN: 'https://gravatar.loli.net/avatar/',
    pageSize: 10,
    lang: 'en',
    locale: {
      placeholder: 'Share your thoughts about this discovery...',
      sofa: 'Be the first to comment!',
      submit: 'Submit',
      reply: 'Reply',
      cancelReply: 'Cancel Reply',
      comment: 'Comment',
      refresh: 'Refresh',
      more: 'Load More...',
      preview: 'Preview',
      emoji: 'Emoji',
      uploadImage: 'Upload Image',
      seconds: 'seconds ago',
      minutes: 'minutes ago',
      hours: 'hours ago',
      days: 'days ago',
      now: 'just now'
    },
    emoji: [
      '//unpkg.com/@waline/emojis@1.2.0/weibo',
      '//unpkg.com/@waline/emojis@1.2.0/alus',
      '//unpkg.com/@waline/emojis@1.2.0/bilibili',
      '//unpkg.com/@waline/emojis@1.2.0/qq',
      '//unpkg.com/@waline/emojis@1.2.0/tieba'
    ],
    dark: 'auto',
    imageUploader: false,
    highlight: true,
    mathml: false,
    search: false,
    pageview: true,
    comment: true,
    copyright: false
  });
</script>

<style>
  .single-post {
    max-width: 680px;
    margin: 0 auto;
    padding: 0 0 80px 0;
  }
  
  .post-header {
    margin-bottom: 48px;
    text-align: center;
  }
  
  .post-title {
    font-size: 36px;
    font-weight: 600;
    line-height: 1.2;
    margin-bottom: 16px;
    letter-spacing: -0.02em;
    color: var(--text-primary-light);
    font-family: 'Work Sans', sans-serif;
  }
  
  body.dark .post-title {
    color: var(--text-primary-dark);
  }
  
  .post-meta {
    font-size: 12px;
    color: var(--text-tertiary-light);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    font-weight: 500;
  }
  
  body.dark .post-meta {
    color: var(--text-tertiary-dark);
  }
  
  .post-content {
    font-size: 19px;
    line-height: 1.8;
    margin-bottom: 48px;
  }
  
  .post-tags {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
    margin-bottom: 32px;
    justify-content: center;
  }
  
  .tag {
    color: var(--text-secondary-light);
    text-decoration: none;
    font-size: 13px;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    transition: color 0.2s ease;
  }
  
  .tag:hover {
    color: var(--text-primary-light);
  }
  
  body.dark .tag {
    color: var(--text-secondary-dark);
  }
  
  body.dark .tag:hover {
    color: var(--text-primary-dark);
  }
  
  .post-actions {
    display: flex;
    gap: 12px;
    align-items: center;
    justify-content: center;
    flex-wrap: wrap;
    padding-top: 32px;
    border-top: 1px solid var(--border-light);
    position: relative;
  }
  
  body.dark .post-actions {
    border-top-color: var(--border-dark);
  }
  
  .share-btn {
    background: none;
    border: 1px solid var(--border-light);
    color: var(--text-secondary-light);
    padding: 8px 16px;
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    font-weight: 500;
    text-decoration: none;
    display: inline-block;
  }
  
  .share-btn:hover {
    background: var(--accent-light);
    color: var(--text-primary-light);
  }
  
  body.dark .share-btn {
    border-color: var(--border-dark);
    color: var(--text-secondary-dark);
  }
  
  body.dark .share-btn:hover {
    background: var(--accent-dark);
    color: var(--text-primary-dark);
  }
  
  .copy-success {
    font-size: 12px;
    color: var(--text-tertiary-light);
    opacity: 0;
    transition: opacity 0.3s ease;
  }
  
  .copy-success.show {
    opacity: 1;
  }
  
  body.dark .copy-success {
    color: var(--text-tertiary-dark);
  }
  
  .related-posts {
    margin-top: 60px;
    padding-top: 40px;
    border-top: 1px solid var(--border-light);
  }
  
  body.dark .related-posts {
    border-top-color: var(--border-dark);
  }
  
  .section-title {
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 24px;
    color: var(--text-primary-light);
    font-family: 'Work Sans', sans-serif;
    text-align: center;
  }
  
  body.dark .section-title {
    color: var(--text-primary-dark);
  }
  
  .related-posts-grid {
    display: grid;
    gap: 24px;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    margin-top: 24px;
  }
  
  .related-post {
    padding: 24px;
    border: 1px solid var(--border-light);
    background: var(--bg-light);
  }
  
  body.dark .related-post {
    border-color: var(--border-dark);
    background: var(--bg-dark);
  }
  
  .related-post-title {
    font-size: 16px;
    font-weight: 600;
    margin-bottom: 8px;
    line-height: 1.4;
    font-family: 'Work Sans', sans-serif;
  }
  
  .related-post-title a {
    color: var(--text-primary-light);
    text-decoration: none;
  }
  
  .related-post-title a:hover {
    color: var(--accent-orange);
  }
  
  body.dark .related-post-title a {
    color: var(--text-primary-dark);
  }
  
  .related-post-excerpt {
    font-size: 14px;
    color: var(--text-secondary-light);
    line-height: 1.5;
    margin-bottom: 12px;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
  
  body.dark .related-post-excerpt {
    color: var(--text-secondary-dark);
  }
  
  .related-post-tags {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  
  .related-tag {
    font-size: 11px;
    color: var(--text-tertiary-light);
    font-weight: 500;
  }
  
  body.dark .related-tag {
    color: var(--text-tertiary-dark);
  }
  
  .comments-section {
    margin-top: 60px;
    padding-top: 40px;
    border-top: 1px solid var(--border-light);
  }
  
  body.dark .comments-section {
    border-top-color: var(--border-dark);
  }
  
  .comments-title {
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 24px;
    color: var(--text-primary-light);
    font-family: 'Work Sans', sans-serif;
  }
  
  body.dark .comments-title {
    color: var(--text-primary-dark);
  }
  
  /* Waline theme customization */
  :global(.wl-container) {
    font-family: 'Work Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif !important;
  }
  
  :global(.wl-editor) {
    border-radius: 0 !important;
    border: 1px solid var(--border-light) !important;
    background: var(--bg-light) !important;
  }
  
  body.dark :global(.wl-editor) {
    border-color: var(--border-dark) !important;
    background: var(--bg-dark) !important;
    color: var(--text-primary-dark) !important;
  }
  
  :global(.wl-btn) {
    border-radius: 4px !important;
    background: var(--accent-orange) !important;
    border: none !important;
    transition: all 0.2s ease !important;
  }
  
  :global(.wl-btn:hover) {
    background: var(--accent-orange-hover) !important;
  }
  
  :global(.wl-card) {
    border: 1px solid var(--border-light) !important;
    border-radius: 0 !important;
    background: var(--accent-light) !important;
  }
  
  body.dark :global(.wl-card) {
    border-color: var(--border-dark) !important;
    background: var(--accent-dark) !important;
  }
  
  :global(.wl-comment-content) {
    color: var(--text-primary-light) !important;
  }
  
  body.dark :global(.wl-comment-content) {
    color: var(--text-primary-dark) !important;
  }
  
  :global(.wl-meta) {
    color: var(--text-secondary-light) !important;
  }
  
  body.dark :global(.wl-meta) {
    color: var(--text-secondary-dark) !important;
  }
  
  @media (max-width: 768px) {
    .post-title {
      font-size: 28px;
    }
    
    .post-content {
      font-size: 17px;
    }
    
    .post-actions {
      flex-direction: row;
      gap: 8px;
      padding-top: 24px;
    }
    
    .share-btn {
      padding: 6px 12px;
      font-size: 11px;
    }
    
    .related-posts-grid {
      grid-template-columns: 1fr;
      gap: 20px;
    }
    
    .related-post {
      padding: 20px;
    }
  }
</style>

<!-- Automatic Link Previews -->
<script>
// Client-side automatic link preview system
(function() {
  'use strict';

  // Wait for DOM to be ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initLinkPreviews);
  } else {
    initLinkPreviews();
  }

  function initLinkPreviews() {
    console.log('🔌 Initializing automatic link previews...');
    
    // Find all paragraphs in post content
    const postContent = document.querySelector('.post-content');
    if (!postContent) return;

    const paragraphs = postContent.querySelectorAll('p');
    let convertedCount = 0;

    paragraphs.forEach(paragraph => {
      // Check if paragraph contains only a single link where text = href
      const links = paragraph.querySelectorAll('a');
      if (links.length === 1 && paragraph.textContent.trim() === links[0].href) {
        const link = links[0];
        const url = link.href;
        
        console.log('✅ Converting standalone link:', url);
        convertedCount++;
        
        // Replace paragraph with preview card
        const previewCard = createPreviewCard(url);
        paragraph.parentNode.replaceChild(previewCard, paragraph);
        
        // Fetch metadata asynchronously and update with timeout
        Promise.race([
          fetchMetadata(url),
          new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 3000))
        ]).then(metadata => {
          updatePreviewCard(previewCard, metadata);
        }).catch(error => {
          console.warn('Failed to fetch metadata for:', url, error);
          // Use enhanced fallback if fetch fails
          const fallbackMetadata = getFallbackMetadata(url);
          updatePreviewCard(previewCard, fallbackMetadata);
        });
      }
    });

    console.log(`🚀 Converted ${convertedCount} links to previews`);
  }

  function createPreviewCard(url) {
    // Show enhanced fallback immediately
    const fallback = getFallbackMetadata(url);
    
    const previewDiv = document.createElement('div');
    previewDiv.className = 'link-preview';
    previewDiv.innerHTML = `
      <a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer" class="link-preview-card">
        <div class="link-preview-content">
          <div class="link-preview-header">
            <span class="link-preview-domain">${escapeHtml(fallback.siteName)}</span>
          </div>
          <h3 class="link-preview-title">${escapeHtml(fallback.title)}</h3>
          <p class="link-preview-description">${escapeHtml(fallback.description)}</p>
        </div>
      </a>
    `;
    
    return previewDiv;
  }

  function getFallbackMetadata(url) {
    const domain = getDomain(url);
    
    const knownSites = {
      'github.com': { 
        siteName: 'GitHub', 
        favicon: 'https://github.com/favicon.ico',
        getTitle: (url) => {
          const match = url.match(/github\.com\/([^\/]+\/[^\/]+)/);
          return match ? `${match[1]} - GitHub Repository` : 'GitHub Repository';
        }
      },
      'stackoverflow.com': { 
        siteName: 'Stack Overflow', 
        favicon: 'https://stackoverflow.com/favicon.ico',
        getTitle: () => 'Stack Overflow Question'
      },
      'substack.com': { 
        siteName: 'Substack', 
        favicon: 'https://substack.com/favicon.ico',
        getTitle: () => 'Substack Article'
      },
      'economist.com': { 
        siteName: 'The Economist', 
        favicon: 'https://www.economist.com/favicon.ico',
        getTitle: () => 'The Economist Article'
      },
      'dev.to': { 
        siteName: 'DEV Community', 
        favicon: 'https://dev.to/favicon.ico',
        getTitle: () => 'DEV Community Post'
      },
      'medium.com': { 
        siteName: 'Medium', 
        favicon: 'https://medium.com/favicon.ico',
        getTitle: () => 'Medium Article'
      },
      'techcrunch.com': { 
        siteName: 'TechCrunch', 
        favicon: 'https://techcrunch.com/favicon.ico',
        getTitle: () => 'TechCrunch Article'
      }
    };

    const siteInfo = Object.entries(knownSites).find(([key]) => domain.includes(key));
    if (siteInfo) {
      const [, info] = siteInfo;
      return {
        title: info.getTitle(url),
        description: `Read this article on ${info.siteName}`,
        siteName: info.siteName,
        favicon: info.favicon
      };
    }
    
    return {
      title: `${domain} - External Link`,
      description: `Visit this content on ${domain}`,
      siteName: domain
    };
  }

  async function fetchMetadata(url) {
    try {
      const domain = getDomain(url);
      
      // Try to fetch actual metadata using a CORS proxy with timeout
      try {
        const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
        const controller = new AbortController();
        setTimeout(() => controller.abort(), 2000); // 2 second timeout
        
        const response = await fetch(proxyUrl, { signal: controller.signal });
        const data = await response.json();
        
        if (data.contents) {
          const html = data.contents;
          const metadata = extractMetadataFromHtml(html, url);
          if (metadata.title && metadata.title !== 'Link Preview') {
            return metadata;
          }
        }
      } catch (proxyError) {
        console.warn('CORS proxy failed, using fallback metadata');
      }
      
      // Fallback to enhanced domain-based previews
      const knownSites = {
        'github.com': { 
          siteName: 'GitHub', 
          favicon: 'https://github.com/favicon.ico',
          getTitle: (url) => {
            const match = url.match(/github\.com\/([^\/]+\/[^\/]+)/);
            return match ? `${match[1]} - GitHub Repository` : 'GitHub Repository';
          }
        },
        'stackoverflow.com': { 
          siteName: 'Stack Overflow', 
          favicon: 'https://stackoverflow.com/favicon.ico',
          getTitle: () => 'Stack Overflow Question'
        },
        'substack.com': { 
          siteName: 'Substack', 
          favicon: 'https://substack.com/favicon.ico',
          getTitle: () => 'Substack Article'
        },
        'economist.com': { 
          siteName: 'The Economist', 
          favicon: 'https://www.economist.com/favicon.ico',
          getTitle: () => 'The Economist Article'
        },
        'dev.to': { 
          siteName: 'DEV Community', 
          favicon: 'https://dev.to/favicon.ico',
          getTitle: () => 'DEV Community Post'
        },
        'medium.com': { 
          siteName: 'Medium', 
          favicon: 'https://medium.com/favicon.ico',
          getTitle: () => 'Medium Article'
        },
        'techcrunch.com': { 
          siteName: 'TechCrunch', 
          favicon: 'https://techcrunch.com/favicon.ico',
          getTitle: () => 'TechCrunch Article'
        }
      };

      const siteInfo = Object.entries(knownSites).find(([key]) => domain.includes(key));
      if (siteInfo) {
        const [, info] = siteInfo;
        return {
          title: info.getTitle(url),
          description: `Read this article on ${info.siteName}`,
          siteName: info.siteName,
          favicon: info.favicon
        };
      }
      
      return {
        title: `${domain} - External Link`,
        description: `Visit this content on ${domain}`,
        siteName: domain
      };
    } catch (error) {
      console.warn('Error fetching metadata:', error);
      return {
        title: 'External Link',
        description: 'Click to visit this link',
        siteName: getDomain(url)
      };
    }
  }

  function extractMetadataFromHtml(html, url) {
    const metadata = {
      title: extractFromHtml(html, [
        /<meta\s+property="og:title"\s+content="([^"]*)"/i,
        /<meta\s+name="title"\s+content="([^"]*)"/i,
        /<title[^>]*>([^<]+)<\/title>/i
      ]),
      description: extractFromHtml(html, [
        /<meta\s+property="og:description"\s+content="([^"]*)"/i,
        /<meta\s+name="description"\s+content="([^"]*)"/i
      ]),
      image: extractFromHtml(html, [
        /<meta\s+property="og:image"\s+content="([^"]*)"/i,
        /<meta\s+name="twitter:image"\s+content="([^"]*)"/i
      ]),
      siteName: extractFromHtml(html, [
        /<meta\s+property="og:site_name"\s+content="([^"]*)"/i
      ])
    };

    return {
      ...metadata,
      title: metadata.title || getDomain(url),
      description: metadata.description || `Visit this content on ${getDomain(url)}`
    };
  }

  function extractFromHtml(html, patterns) {
    for (const pattern of patterns) {
      const match = html.match(pattern);
      if (match && match[1] && match[1].trim()) {
        return match[1].trim();
      }
    }
    return null;
  }

  function updatePreviewCard(previewDiv, metadata) {
    const domain = getDomain(previewDiv.querySelector('a').href);
    const title = metadata.title || 'Link Preview';
    const description = metadata.description || `Visit ${domain}`;
    const siteName = metadata.siteName || domain;
    
    const titleEl = previewDiv.querySelector('.link-preview-title');
    const descEl = previewDiv.querySelector('.link-preview-description');
    const domainEl = previewDiv.querySelector('.link-preview-domain');
    
    if (titleEl) titleEl.textContent = title;
    if (descEl) descEl.textContent = description;
    if (domainEl) domainEl.textContent = siteName;
    
    // Add favicon if available
    if (metadata.favicon) {
      const headerDiv = previewDiv.querySelector('.link-preview-header');
      const faviconImg = document.createElement('img');
      faviconImg.src = metadata.favicon;
      faviconImg.alt = '';
      faviconImg.className = 'link-preview-favicon';
      headerDiv.insertBefore(faviconImg, headerDiv.firstChild);
    }
  }

  function getDomain(url) {
    try {
      return new URL(url).hostname.replace('www.', '');
    } catch {
      return 'External Link';
    }
  }

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
})();
</script>